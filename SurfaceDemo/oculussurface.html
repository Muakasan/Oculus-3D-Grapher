<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>NPVR surface</title>
        <style>
            html, body {
                width: 100%;
                height: 100%;
            }

            body {
                background-color: #FFFFFF;
                margin: 0;
                overflow: hidden;
                font-family: arial;
            }

            #help {
                position: absolute;
                top: 800px;
            }
            #info {
                position: absolute;
                top: 820px;
            }

            canvas {
                position: absolute;
                top: 0;
                left: 0;
            }

        </style>
    </head>
    <body>
        <script src="vr.js"></script>
        <script src="three.js"></script>
        <script src="js/controls/OculusRiftControls.js"></script>
        <script src="js/effects/OculusRiftEffect.js"></script>
        <div id="info">IPD: <span id='ipd'>0</span> (+o/-p)</div>
        <script>
            (function() {
                var camera, scene, renderer;
                var geometry, material, mesh;
                var controls, time = Date.now();

                var effect;

                var objects = [];

                var ray;

                var cube;

                vr.load(function(error) {
                    if (error) {
                        //statusEl.innerText = 'Plugin load failed: ' + error.toString();
                        //alert('Plugin load failed: ' + error.toString());
                    }

                    init();
                    animate();
                    /*} catch (e) {
                        //statusEl.innerText = e.toString();
                        console.log(e);
                    }*/
                });
                function init() {
                    camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
                    scene = new THREE.Scene();

                    controls = new THREE.OculusRiftControls( camera );
                    scene.add( controls.getObject() );

                    ray = new THREE.Raycaster();
                    ray.ray.direction.set( 0, -1, 0 );

                    //var test = new THREE.Geometry();
                    //test.computeCentroids();

                    //geometry = new THREE.CubeGeometry( 20, 20, 20 )
                    //material = new THREE.MeshBasicMaterial({color:0x0000ff, wireframe:true});

                    //console.log(geometry);

                    parGeometry = new THREE.ParametricGeometry(mobius(20,20,100), 100, 100);
                    parMaterial = new THREE.MeshBasicMaterial({color:0x0000ff, wireframe:true});

                    curve = new THREE.Mesh(parGeometry, parMaterial);

                    //cube = new THREE.Mesh( geometry, material );
                    
                    //console.log(cube.computeCentroids());

                    /*cube.position.x = 10;
                    cube.position.y = 10;
                    cube.position.z = -10;
                    scene.add(cube);
                    objects.push(cube);*/
                    scene.add(curve);
                    objects.push(curve);

                    renderer = new THREE.WebGLRenderer({
                        devicePixelRatio: 1,
                        alpha: false,
                        clearColor: 0xFFFFFF,
                        antialias: true
                    });
                    effect = new THREE.OculusRiftEffect(renderer);

                    

                    document.getElementById('ipd').innerHTML =
                        effect.getInterpupillaryDistance().toFixed(3);

                    document.body.appendChild( renderer.domElement );
                }
                var vrstate = new vr.State();
                function animate() {
                    vr.requestAnimationFrame(animate);

                    //cube.rotation.x+=0.1;
                    //cube.rotation.y+=0.1;

                    controls.isOnObject(false);

                    ray.ray.origin.copy(controls.getObject().position);
                    ray.ray.origin.y -= 10;

                    var intersections = ray.intersectObjects(objects);
                    if(intersections.length>0) {
                        var distance = intersections[0].distance;
                        if(distance>0 && distance<10) {
                            controls.isOnObject(true);
                        }
                    }

                    var polled = vr.pollState(vrstate);
                    controls.update(Date.now() - time, polled ? vrstate: null);

                    effect.render(scene, camera, polled ? vrstate : null);

                    time = Date.now();
                    //console.log("x: ", )
                }

                function cone(a, b, c) {
                    return function(u,v) {
                        var x = a*v*Math.cos(2*Math.PI*u)*100;
                        var y = b*v*Math.sin(2*Math.PI*u)*100;
                        var z = c*v*100;
                        return new THREE.Vector3(z,x,y);
                    }
                }

                function ellipsoid(a,b,c) {
                    return function(u,v) {
                        var x = a*Math.sin(2*Math.PI*u)*Math.cos(2*Math.PI*v)*100;
                        var y = b*Math.sin(2*Math.PI*u)*Math.sin(2*Math.PI*v)*100;
                        var z = c*Math.cos(2*Math.PI*u)*100;
                        return new THREE.Vector3(x,y,z);
                    }
                }


                function hyperboloidOne(a,b,c) {
                    return function(u,v) {
                        var x = a*Math.sqrt(1^u*u)*Math.cos(2*Math.PI*v)*100;
                        var y = a*Math.sqrt(1+u*u)*Math.sin(2*Math.PI*v)*100;
                        var z = c*u*100;
                        return new THREE.Vector3(x,y,z);
                    }
                }

                function paraboloid(a,b) {
                    return function(u,v) {
                        var x = a*Math.sqrt(u)*Math.cos(2*Math.PI*v)*100;
                        var y = b*Math.sqrt(u)*Math.sin(2*Math.PI*v)*100;
                        var z = u * 100;
                        return new THREE.Vector3(x,y,z);
                    }
                }

                function hyperboloidTwo(a,b,c) {
                    return function(u,v)  {
                        var x = a*Math.sinh(2*Math.PI*fu)*Math.cos(2*Math.PI*v)*100;
                        var y = a*Math.sinh(2*Math.PI*u)*Math.sin(2*Math.PI*v)*100;
                        var z = c*Math.cosh(2*Math.PI*u)*100;
                        return new THREE.Vector3(x,y,z);
                    }
                }

                function torus(a,c) { 
                    return function(u,v) {
                        var x = (c+a*Math.cos(2*Math.PI*v))*Math.cos(2*Math.PI*u);

                        var y = (c+a*Math.cos(2*Math.PI*v))*Math.sin(2*Math.PI*u);
                        var z = a*Math.sin(Math.PI*v);
                        //var x = a*Math.cos(2*Math.PI*u)+b*Math.cos(2*Math.PI*v)*Math.cos(2*Math.PI*u)*100;
                        //var y = c*Math.sin(2*Math.PI*u)+d*Math.cos(2*Math.PI*v)*Math.sin(2*Math.PI*u)*100;
                        //var z = e*Math.sin(2*Math.PI*v)*100;
                        return new THREE.Vector3(x,y,z);
                    }
                }

                function shell(a,b,c) {
                    return function(u,v) {
                        var x = Math.pow(a,v)*Math.sin(2*Math.PI*u)*Math.sin(2*Math.PI*u)*Math.cos(2*Math.PI*v)*100;
                        var y = Math.pow(b,v)*Math.sin(2*Math.PI*u)*Math.sin(2*Math.PI*u)*Math.sin(2*Math.PI*v)*100;
                        var z = Math.pow(c,v)*Math.sin(2*Math.PI*u)*Math.cos(2*Math.PI*u)*100;
                        return new THREE.Vector3(x,y,z);
                    }
                }

                function trumpet(a,b) {
                    return function(u,v) {  
                        var x = u*100;
                        var y = a*Math.cos(2*Math.PI*v)/u*100;
                        var z = b*Math.sin(2*Math.PI*v)/u*100;
                        return new THREE.Vector3(x,y,z);
                    }
                }

                function mobius(a,b) {
                    return function(u,v) {
                        var x = (a+v*Math.cos(0.5*2*Math.PI*u))*Math.cos(2*Math.PI*u);
                        var y = (b+v*Math.sin(0.5*2*Math.PI*u))*Math.cos(2*Math.PI*u);
                        var z = v*Math.sin(0.5*2*Math.PI*u);
                        return new THREE.Vector3(x,y,z);
                    }
                }
            })();
        </script>
    </body>
</html>